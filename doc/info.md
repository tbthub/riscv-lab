### 用户中断

我们这个破内核的中断借鉴 XV6, 某些地方有修改

1. `硬件自动完成`
   1. 禁中断（嵌套太麻烦了，或者至少上半部你别在来了）
   2. 切换到监管模式（内核态、管态）
   3. sepc <-pc；保存PC 指针（程序断点）
   4. Scause：Trap发生的原因

处理完成上面这一部分后CPU跳转到`stvec`寄存器存放的地址（就是赋给`PC`）。所以用户程序运行时候这个一定要初始化为`uservec`，在内核运行时为`kernelvec`。由这个地址进入下一步处理阶段。



2. `uservec`
   1. 加载内核栈（理论上内核栈应该是空的，也就是栈顶和栈底一样，可以通过`PCB`计算获取位置）
   2. 保存所有寄存器到内核栈
   3. 跳转到`usertrap`

我们直接把内核空间也放在用户的虚拟地址中，这样可以避免因为切换页表带来的开销。用户程序在链接时需使用我们的的链接脚本。

这里问题来了，我们如何知道其内核栈的地址呢？
解决方案：

- 对于所有的用户程序，当准备从内核态返回到用户态时候，也就是中断返回的时候，我们选择其 scratch 寄存器存放内核栈的地址，当中断发生的时候，就直接使用。



3. `usertrap`
   1. 实际处理中断


4. 上述依次返回

中断的流程中，会涉及到页表的切换：

1. **中断发生**的时候，由于内核空间也被映射到用户页表，内核可以直接使用用户页表，因此没有必要进行页表切换。

2. **中断返回**的时候
   1. 前后页表**一致**，即具有相同页表的线程，在切换的时候可以不用切换页表。
      - 自己中断发生，处理后返回，假如没下处理机 
      - 同一进程的若干线程（共用一副页表）
   2. 前后页表**不一致**，即发生了进程切换，此时需要切换页表

对于切换页表的代码位置，我们选择在 `usertrapret`(kernel/trap.c) 进行操作。由于此代码位于内核空间，所有进程又都共用一个该内核空间，即使发生页表切换，也能够代码顺利执行下去。

在用户态，中断发生的时候，CPU会自动跳转到 uservec，在这里会将寄存器保存在线程的内核栈中。

假如要发生进程切换，那么会有一次上下文切换 （switch context），在这里会再次保存一次寄存器。

当第一个用户程序需要运行的时候，首先要为其准备好上下文 context：
   ra: forkret
   sp: 内核栈指针，我们设置为其内核栈顶。



上下文完成切换后，需要退出中断。在 userret 中会再次恢复一次寄存器，并通过 sret 返回：
   sp: 用户栈指针（这个 sp 是tf中存放的 sp）。在虚拟地址 0x1fff...忘了。
   epc:返回后的 pc （代码段），在虚拟地址 0x200,000,000。 



### 缺页异常

在`riscv64`有三种缺页异常：

1. **Instruction Page Fault（scause = 12）**

1. **Load Page Fault（scause = 13）**

1. **Store/AMO Page Fault（scause = 15）**




| 场景           | 访问类型          | scause | 原因                     |
| -------------- | ----------------- | ------ | ------------------------ |
| 未映射地址执行 | Instruction Fetch | 12     | 页表项不存在或权限不足   |
| 未映射地址读取 | Load（读操作）    | 13     | 页表项不存在或权限不足   |
| 未映射地址写入 | Store（写操作）   | 15     | 页表项不存在或权限不足   |
| COW 页写入     | Store（写操作）   | 15     | 页表项标记为只读（需复制） |

下面讨论的异常地址都是“正常”地址，即排除

- 故意访问内核
- 故意以错误的权限访问（比如写代码段）
- 不在`vma`管理范围之中的情况。

对于上述三种异常（严格来说一二是一类，一三也是一类），则应该直接杀死线程。

> 注：
> 1. 对于`写`异常(scause = 15)，需要先检查是不是 COW
> 2. `find_vma`如果返回空可以直接包含1和3（我们不把内核空间放入 vma，尽管它确实位于用户虚存）


1.  **12**：
    1. CPU 尝试从`未映射`的虚拟地址`执行`指令，即找不到页表项
    2. 该页面不能`执行`

对于正常的地址，如果有懒分配标志，则直接分配；如果没有懒分配标志，这种情况一般发生在当我们执行一个可执行文件的时候，我们只把其部分的内容读入内存，没有读完。我们仅仅是在其 `mm_struct`的某个虚存段`vma`中把代码段放置了位置。此时，当CPU执行到这里后，因为后面的地址没有加载进入内存，因此需要将文件读入。根据此地址与 `start_code`相减即可以计算出偏移地址offset，根据offset + 文件的代码段偏移即可定位到待读入地址。申请一个新页面，将其建立页表映射，然后将其内容按页读入即可返回。



2.  **13**
    1. CPU尝试从`未映射`的虚拟地址`读取`数据，即找不到页表项
    2. 该页面不能`读`

同12的处理办法






3.  **15**
    1. CPU尝试从`未映射`的虚拟地址`写入`数据，即找不到页表项
    1. 该页面不能`写`

对于正常的地址，发生时机要多一点，处理情况要麻烦点：

- 文件
- COW

对于文件来说，同上操作即可。

对于 COW 来说，哪个进程先触发就为谁新开一页。

对于触发进程来说，需要查看页面的引用数。如果页面引用数:

- \>1  新开一个 `PTE`,一个新页面，复制页面信息，写`prot` 
- =1  直接恢复 `prot`。保证后面那个进程恢复写权限

