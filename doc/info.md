### 用户中断

我们这个破内核的中断借鉴 XV6, 某些地方有修改

1. `硬件自动完成`
   1. 禁中断（嵌套太麻烦了，或者至少上半部你别在来了）
   2. 切换到监管模式（内核态、管态）
   3. sepc <-pc；保存PC 指针（程序断点）
   4. Scause：Trap发生的原因

处理完成上面这一部分后CPU跳转到`stvec`寄存器存放的地址（就是赋给`PC`）。所以用户程序运行时候这个一定要初始化为`uservec`，在内核运行时为`kernelvec`。由这个地址进入下一步处理阶段。



2. `uservec`
   1. 加载内核栈（理论上内核栈应该是空的，也就是栈顶和栈底一样，可以通过`PCB`计算获取位置）
   2. 保存所有寄存器到内核栈
   3. 跳转到`usertrap`

我们直接把内核空间也放在用户的虚拟地址中，这样可以避免因为切换页表带来的开销。用户程序在链接时需使用我们的的链接脚本。

这里问题来了，我们如何知道其内核栈的地址呢？
解决方案：
- 对于所有的用户程序，当准备从内核态返回到用户态时候，也就是中断返回的时候，我们选择其 scratch 寄存器存放内核栈的地址，当中断发生的时候，就直接使用。



3. `usertrap`
   1. 实际处理中断


4. 上述依次返回

中断的流程中，会涉及到页表的切换：

1. **中断发生**的时候，由于内核空间也被映射到用户页表，内核可以直接使用用户页表，因此没有必要进行页表切换。

2. **中断返回**的时候
   1. 前后页表**一致**，即具有相同页表的线程，在切换的时候可以不用切换页表。
      - 自己中断发生，处理后返回，假如没下处理机 
      - 同一进程的若干线程（共用一副页表）
   2. 前后页表**不一致**，即发生了进程切换，此时需要切换页表

对于切换页表的代码位置，我们选择在 `usertrapret`(kernel/trap.c) 进行操作。由于此代码位于内核空间，所有进程又都共用一个该内核空间，即使发生页表切换，也能够代码顺利执行下去。

在用户态，中断发生的时候，CPU会自动跳转到 uservec，在这里会将寄存器保存在线程的内核栈中。
假如要发生进程切换，那么会有一次上下文切换 （switch context），在这里会再次保存一次寄存器。
当第一个用户程序需要运行的时候，首先要为其准备好上下文 context：
   ra: forkret
   sp: 内核栈指针，由于是模拟的内核栈，因此应该需要假装是中断过的，也就是 top - 256?

上下文完成切换后，需要退出中断。在 userret 中会再次恢复一次寄存器，并通过 sret 返回：
   sp: 用户栈指针（这个 sp 是内核栈中存放的 sp）。
   epc:返回后的 pc  
