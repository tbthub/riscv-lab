### 用户中断

我们这个破内核的中断借鉴 XV6, 某些地方有修改

1. `硬件自动完成`
   1. 禁中断（嵌套太麻烦了，或者至少上半部你别在来了）
   2. 切换到监管模式（内核态、管态）
   3. sepc <-pc；保存PC 指针（程序断点）
   4. Scause：Trap发生的原因

处理完成上面这一部分后CPU跳转到`stvec`寄存器存放的地址（就是赋给`PC`）。所以用户程序运行时候这个一定要初始化为`uservec`，在内核运行时为`kernelvec`。由这个地址进入下一步处理阶段。



2. `uservec`
   1. 加载内核栈（理论上内核栈应该是空的，也就是栈顶和栈底一样，可以通过`PCB`计算获取位置）
   2. 保存所有寄存器到内核栈
   3. 跳转到`usertrap`

我们直接把内核空间也放在用户的虚拟地址中，这样可以避免因为切换页表带来的开销。用户程序在链接时需使用我们的的链接脚本。

这里问题来了，我们如何知道其内核栈的地址呢？
解决方案：
- 对于所有的用户程序，当准备从内核态返回到用户态时候，也就是中断返回的时候，我们选择其 scratch 寄存器存放内核栈的地址，当中断发生的时候，就直接使用。



3. `usertrap`
   1. 实际处理中断



4. 上述依次返回