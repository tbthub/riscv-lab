1. 关于引用计数 `refcnt`

​		当引用计数减为 0 时。并没有其他额外的什么操作。也就是说并不释放其资源，该 **inode**仍然在哈希表中，在全局仍有。只不过此时没有任何线程正在使用这个文件。后面如果是从目录项中的 **inode ptr**查找到的，则需要 `idup`操作来增加引用计数。如果在 **dentry** 的 **inode ptr**没有，则相当于在哈希表中查找，此时 **inode**引用计数的增加应该是在`iget`函数中而不是`idup`。

​		关于内存中 **inode** 资源的释放，应该由 **LRU** 进行管理。具体一点的话，可以类似使用 **LRU2** 来进行处理访问，释放由 `efs_sync`线程负责。这个线程释放**inode** 的内存资源，同时也伴随脏 **inode** 的写回释放。

​		关于磁盘上 **inode** 的回收问题。首先应该在引用计数为 0 的时候，也就是 `refcnt`为0，即没有线程正在使用的时候才允许回收。一般情况下，对其链接数`nlink`原子自减。当`nlink`为0时，这个时候才决定正式回收。

​		接上段，既然已经决定回收了，那么内存中的相关数据和结构也就没有必要存在了。应该让其从脏链先拿下来，防止写回磁盘。如果已经在写，则写的时候是持有睡眠锁的。因此，在拿下来的时候，需要对 **inode** 增加睡眠锁。然后陆陆续续解除其他的内存结构，最后释放空间。对于需要回收的磁盘空间来说，可以简单的只把`bamp & imap`位图给做标记，加上标记文件大小为0。不需要其他额外的相关操作。